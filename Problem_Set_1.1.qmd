---
title: "Problem Set 1"
author: "Charlie Jordan"
format:
  html:
    embed-resources: true 
    code-fold: true
    fig-format: png
execute:
  echo: true
  warning: false
  message: false
---

```{r setup}
# ============================
# File paths (GitHub raw URLs)
# ============================
abalone_data_path <- "https://raw.githubusercontent.com/charlieejordan/Stats_506_Fall_2025/main/abalone.data"
food_path         <- "https://raw.githubusercontent.com/charlieejordan/Stats_506_Fall_2025/main/food_expenditure.csv"

# ============================
# Helpers
# ============================
clean_names_base <- function(nms) {
  nms <- gsub("[^A-Za-z0-9]+", "_", nms)
  nms <- gsub("^_+|_+$", "", nms)
  nms <- tolower(nms)
  nms[nms == ""] <- paste0("x", seq_len(sum(nms == "")))
  make.unique(nms, sep = "_")
}

safe_cor <- function(x, y) {
  x <- suppressWarnings(as.numeric(x))
  y <- suppressWarnings(as.numeric(y))
  if (!length(x) || !length(y)) return(NA_real_)
  if (all(!is.finite(x)) || all(!is.finite(y))) return(NA_real_)
  suppressWarnings(stats::cor(x, y, use = "complete.obs"))
}

guess_col <- function(nms, patterns) {
  for (p in patterns) {
    hits <- grep(p, nms, ignore.case = TRUE, value = TRUE)
    if (length(hits) > 0) return(hits[1])
  }
  NA_character_
}

guess_numeric_cols <- function(df, patterns, k = 4, exclude = character(0)) {
  nms <- names(df)
  cand <- unique(unlist(lapply(patterns, function(p) grep(p, nms, ignore.case = TRUE, value = TRUE))))
  cand <- setdiff(cand, exclude)
  cand <- cand[vapply(df[cand], is.numeric, TRUE)]
  if (length(cand) >= k) return(cand[1:k])
  nums <- nms[vapply(df, is.numeric, TRUE)]
  nums <- setdiff(nums, exclude)
  if (!length(nums)) return(character(0))
  vrs <- sapply(df[nums], function(x) var(x, na.rm = TRUE))
  nums[order(vrs, decreasing = TRUE)][1:min(k, length(nums))]
}
```

# Problem 1 — Abalone Data

```{r}
abalone <- read.csv(abalone_data_path, header = FALSE, stringsAsFactors = FALSE)
names(abalone) <- c(
  "sex","length","diameter","height",
  "whole_weight","shucked_weight","viscera_weight","shell_weight","rings"
)
num_cols <- setdiff(names(abalone), "sex")
for (nm in num_cols) abalone[[nm]] <- suppressWarnings(as.numeric(abalone[[nm]]))
head(abalone, 5)

```

## Observations by sex

```{r}
as.data.frame(table(abalone$sex))
```

## Which weight has the highest correlation with rings?

```{r}
weight_vars <- c("whole_weight","shucked_weight","viscera_weight","shell_weight")

corr_overall <- data.frame(
  weight = weight_vars,
  correlation = sapply(weight_vars, function(v) safe_cor(abalone[[v]], abalone$rings)),
  stringsAsFactors = FALSE
)
corr_overall <- corr_overall[order(-corr_overall$correlation), ]
corr_overall

```

**Answer (overall):** The top row above is the most correlated weight with `rings`.

## For that weight, which sex has the highest correlation with rings?

```{r}
top_weight <- corr_overall$weight[which.max(corr_overall$correlation)]
sp <- split(abalone, abalone$sex)
data.frame(
  sex = names(sp),
  correlation = sapply(sp, function(df) safe_cor(df[[top_weight]], df$rings))
)
```

**Answer (by sex):** The first row above shows the sex with the highest correlation for `top_weight`.

## What are the weights of the abalone with the most rings?

```{r}
cols_to_show <- c("sex", weight_vars, "rings")
abalone[abalone$rings == max(abalone$rings, na.rm = TRUE), cols_to_show]

```

## What percentage of abalones have viscera weight \> shell weight?

```{r}
round(mean(abalone$viscera_weight > abalone$shell_weight, na.rm = TRUE) * 100, 2)

```

## Correlations between weights and rings, by sex

```{r}
do.call(rbind, lapply(split(abalone, abalone$sex), function(df) {
  data.frame(
    sex = unique(df$sex),
    whole_weight   = safe_cor(df$whole_weight,   df$rings),
    shucked_weight = safe_cor(df$shucked_weight, df$rings),
    viscera_weight = safe_cor(df$viscera_weight, df$rings),
    shell_weight   = safe_cor(df$shell_weight,   df$rings)
  )
}))
```

## Table: correlations between weights and rings, within each sex

```{r}
do.call(rbind, lapply(split(abalone, abalone$sex), function(df) {
  data.frame(
    sex = unique(df$sex),
    whole_weight   = safe_cor(df$whole_weight,   df$rings),
    shucked_weight = safe_cor(df$shucked_weight, df$rings),
    viscera_weight = safe_cor(df$viscera_weight, df$rings),
    shell_weight   = safe_cor(df$shell_weight,   df$rings)
  )
}))

```

## Welch t-tests: do mean rings differ across sexes?

```{r}
sexes  <- unique(abalone$sex)
pairs  <- combn(sexes, 2, simplify = FALSE)
lapply(pairs, function(p) {
  g1 <- abalone$rings[abalone$sex == p[1]]
  g2 <- abalone$rings[abalone$sex == p[2]]
  list(pair = paste(p, collapse = " vs "), ttest = t.test(g1, g2))
})
```

**Interpretation:** Use the p-values above (e.g., α = 0.05) to state which sex pairs differ significantly in mean rings; compare to group means for direction.

# Problem 2

```{r}
# Guess a column name by matching patterns (case-insensitive).
guess_col <- function(nms, patterns) {
  for (p in patterns) {
    hits <- grep(p, nms, ignore.case = TRUE, value = TRUE)
    if (length(hits) > 0) return(hits[1])  # return first match
  }
  NA_character_
}
```

```{r}
food <- read.csv(food_path, stringsAsFactors = FALSE)
names(food) <- clean_names_base(names(food))
head(food, 3)

```

## Restrict to USD (show counts before/after)

```{r}
n_before <- nrow(food)
currency_col <- guess_col(names(food), c("^currency$","currency"))
food_usd <- food
if (!is.na(currency_col)) {
  cur_upper <- toupper(as.character(food[[currency_col]]))
  food_usd <- food[cur_upper == "USD", ]
}
data.frame(before = n_before, after_usd = nrow(food_usd))

```

## Cleaning rules (documented) and implementation

```{r}
dat <- food_usd
age_col   <- guess_col(names(dat), c("^age$","age"))
state_col <- guess_col(names(dat), c("^state$","state"))

if (!is.na(age_col)) {
  dat[[age_col]] <- as.numeric(dat[[age_col]])
  dat <- dat[dat[[age_col]] >= 18 & dat[[age_col]] <= 100, ]
}
if (!is.na(state_col)) {
  st <- toupper(trimws(as.character(dat[[state_col]])))
  dat <- dat[grepl("^[A-Z]{2}$", st), ]
}

food_cols <- guess_numeric_cols(dat,
  patterns = c("food","grocer","home","away","restaur","dining","eat"),
  k = 4, exclude = c(age_col, state_col, currency_col))

for (fc in food_cols) {
  dat[[fc]] <- as.numeric(dat[[fc]])
  dat <- dat[dat[[fc]] >= 0, ]
  cap <- quantile(dat[[fc]], 0.995, na.rm = TRUE)
  dat <- dat[dat[[fc]] <= cap, ]
}

dining_col <- guess_col(names(dat), c("dining","times_out","eat_out","meals_out"))
if (!is.na(dining_col)) {
  dat[[dining_col]] <- as.numeric(dat[[dining_col]])
  dat <- dat[dat[[dining_col]] >= 0 & abs(dat[[dining_col]] - round(dat[[dining_col]])) < 1e-8, ]
}

nrow(dat)

```

```{r}
dat <- food_usd

# Identify common fields (best-effort)
age_col   <- guess_col(names(dat), c("^age$","age"))
state_col <- guess_col(names(dat), c("^state$","state"))

# Age rule
if (!is.na(age_col)) {
  dat[[age_col]] <- suppressWarnings(as.numeric(dat[[age_col]]))
  dat <- dat[is.finite(dat[[age_col]]) & dat[[age_col]] >= 18 & dat[[age_col]] <= 100, , drop = FALSE]
}

# State rule
if (!is.na(state_col)) {
  st <- toupper(trimws(as.character(dat[[state_col]])))
  dat <- dat[!is.na(st) & grepl("^[A-Z]{2}$", st), , drop = FALSE]
}

# Food expenditure columns (try name patterns; fallback to numeric variance)
food_cols <- guess_numeric_cols(
  dat,
  patterns = c("food","grocer","home","away","restaur","dining","eat"),
  k = 4,
  exclude = c(age_col, state_col, currency_col)
)

# Non-negative & finite; then drop >99.5th percentile per-column
if (length(food_cols)) {
  for (fc in food_cols) {
    dat[[fc]] <- suppressWarnings(as.numeric(dat[[fc]]))
    dat <- dat[is.finite(dat[[fc]]) & dat[[fc]] >= 0, , drop = FALSE]
    cap <- suppressWarnings(quantile(dat[[fc]], 0.995, na.rm = TRUE))
    if (is.finite(cap)) dat <- dat[dat[[fc]] <= cap | is.na(dat[[fc]]), , drop = FALSE]
  }
}

# Dining-out count (optional)
dining_col <- guess_col(names(dat), c("dining","times_out","eat_out","meals_out"))
if (!is.na(dining_col)) {
  dat[[dining_col]] <- suppressWarnings(as.numeric(dat[[dining_col]]))
  keep <- is.finite(dat[[dining_col]]) & dat[[dining_col]] >= 0 & abs(dat[[dining_col]] - round(dat[[dining_col]])) < 1e-8
  dat <- dat[keep, , drop = FALSE]
}

list(
  used_columns = list(
    currency = currency_col,
    age = age_col,
    state = state_col,
    food_expenditures = food_cols,
    dining_out = dining_col
  ),
  final_observations = nrow(dat)
)
```

```{r}
# ============================
# Problem 2 — CLEANING (robust, explained)
# ============================

dat0 <- food_usd  # from the USD restriction step
n_start <- nrow(dat0)

# ---- helper: count removals ----
removed <- function(before, after) paste0(before - after, " removed (", round(100*(before - after)/max(1,before), 1), "%)")

cat("Starting rows after USD restriction:", n_start, "\n\n")

# ---- identify columns ----
# Try to find age / state / dining-out columns
age_col    <- guess_col(names(dat0), c("^age$","\\bage\\b"))
state_col  <- guess_col(names(dat0), c("^state$","\\bstate\\b"))
dining_col <- guess_col(names(dat0), c("dining","times_out","eat_out","meals_out","restaurants_outings"))

# Try to find food expenditure columns (aim for 4)
# Prefer explicitly named ones if available
explicit_food <- intersect(names(dat0), c("food_home","food_out","total_food","other_food",
                                          "food_at_home","food_away","groceries","restaurants",
                                          "food_total","total"))
explicit_food <- explicit_food[vapply(dat0[explicit_food], is.numeric, TRUE)]

if (length(explicit_food) >= 4) {
  food_cols <- explicit_food[1:4]
} else {
  food_cols <- unique(c(explicit_food,
                        guess_numeric_cols(dat0, patterns = c("food","grocer","home","away","restaur","dining","eat"),
                                           k = 4, exclude = c(age_col, state_col, dining_col))))
  food_cols <- food_cols[vapply(dat0[food_cols], is.numeric, TRUE)]
  food_cols <- food_cols[1:min(4, length(food_cols))]
}

cat("Detected columns:\n")
print(list(age = age_col, state = state_col, food_cols = food_cols, dining_out = dining_col))
cat("\n")

# ---- 1) AGE: 18–100 inclusive ----
dat <- dat0
if (!is.na(age_col) && age_col %in% names(dat)) {
  before <- nrow(dat)
  dat[[age_col]] <- suppressWarnings(as.numeric(dat[[age_col]]))
  keep <- is.finite(dat[[age_col]]) & dat[[age_col]] >= 18 & dat[[age_col]] <= 100
  dat <- dat[keep, , drop = FALSE]
  after <- nrow(dat)
  cat("Age filter (18–100): ", removed(before, after), "\n", sep = "")
} else {
  cat("Age column not found — skipping age filter.\n")
}

# ---- 2) STATE: valid two-letter codes (50 states + DC + PR) ----
valid_states <- c("AL","AK","AZ","AR","CA","CO","CT","DE","FL","GA",
                  "HI","ID","IL","IN","IA","KS","KY","LA","ME","MD",
                  "MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ",
                  "NM","NY","NC","ND","OH","OK","OR","PA","RI","SC",
                  "SD","TN","TX","UT","VT","VA","WA","WV","WI","WY",
                  "DC","PR")

if (!is.na(state_col) && state_col %in% names(dat)) {
  before <- nrow(dat)
  st <- toupper(trimws(as.character(dat[[state_col]])))
  keep <- !is.na(st) & st %in% valid_states
  dat <- dat[keep, , drop = FALSE]
  after <- nrow(dat)
  cat("State filter (valid USPS codes): ", removed(before, after), "\n", sep = "")
} else {
  cat("State column not found — skipping state filter.\n")
}

# ---- 3) FOOD EXPENDITURES: finite, >= 0, and < Q3+3*IQR per column ----
if (length(food_cols) > 0) {
  for (fc in food_cols) {
    before <- nrow(dat)
    dat[[fc]] <- suppressWarnings(as.numeric(dat[[fc]]))
    keep0 <- is.finite(dat[[fc]]) & dat[[fc]] >= 0
    dat <- dat[keep0, , drop = FALSE]
    mid <- nrow(dat)

    # robust high outliers: Q3 + 3*IQR (only if enough variation)
    q <- suppressWarnings(quantile(dat[[fc]], probs = c(0.25, 0.75), na.rm = TRUE))
    iqr <- diff(q)
    if (is.finite(iqr) && iqr > 0) {
      upper <- q[2] + 3*iqr
      keep1 <- dat[[fc]] <= upper
      dat <- dat[keep1, , drop = FALSE]
    }
    after <- nrow(dat)

    cat("Food column '", fc, "': non-neg/finite ", removed(before, mid),
        "; high outliers ", removed(mid, after), "\n", sep = "")
  }
} else {
  cat("Could not identify food expenditure columns — skipping food cleaning.\n")
}

# ---- 3b) Optional consistency: total >= sum(components) if total & components exist ----
# Try to identify a total column and up to two component columns among food_cols
total_candidates <- intersect(c("total_food","food_total","total"), food_cols)
component_candidates <- setdiff(food_cols, total_candidates)

if (length(total_candidates) >= 1 && length(component_candidates) >= 1) {
  total_col <- total_candidates[1]
  # take up to two components for a simple check
  comp_cols <- component_candidates[1:min(2, length(component_candidates))]

  before <- nrow(dat)
  row_sum <- rowSums(dat[comp_cols], na.rm = TRUE)
  tol <- 1e-6
  keep <- is.finite(dat[[total_col]]) & dat[[total_col]] + tol >= row_sum
  dat <- dat[keep, , drop = FALSE]
  after <- nrow(dat)
  cat("Consistency check (", total_col, " >= sum(", paste(comp_cols, collapse = "+"), ")): ",
      removed(before, after), "\n", sep = "")
} else {
  cat("No clear total+components layout found — skipping consistency check.\n")
}

# ---- 4) DINING OUT: integer-like, >= 0, finite; drop high outliers by Q3+3*IQR ----
if (!is.na(dining_col) && dining_col %in% names(dat)) {
  before <- nrow(dat)
  dat[[dining_col]] <- suppressWarnings(as.numeric(dat[[dining_col]]))
  keep0 <- is.finite(dat[[dining_col]]) & dat[[dining_col]] >= 0 & abs(dat[[dining_col]] - round(dat[[dining_col]])) < 1e-8
  dat <- dat[keep0, , drop = FALSE]
  mid <- nrow(dat)

  q <- suppressWarnings(quantile(dat[[dining_col]], probs = c(0.25, 0.75), na.rm = TRUE))
  iqr <- diff(q)
  if (is.finite(iqr) && iqr > 0) {
    upper <- q[2] + 3*iqr
    keep1 <- dat[[dining_col]] <= upper
    dat <- dat[keep1, , drop = FALSE]
  }
  after <- nrow(dat)

  cat("Dining-out '", dining_col, "': integer/non-neg/finite ", removed(before, mid),
      "; high outliers ", removed(mid, after), "\n", sep = "")
} else {
  cat("Dining-out column not found — skipping dining-out filters.\n")
}

cat("\nFinal rows after cleaning: ", nrow(dat), " (from ", n_start, ")\n", sep = "")

# Return a compact summary object so it prints nicely in HTML
list(
  chosen_columns = list(age = age_col, state = state_col, food_cols = food_cols, dining_out = dining_col),
  final_n = nrow(dat)
)

```

# Problem 3 — Collatz Conjecture

```{r}
nextCollatz <- function(n) {
  if (length(n)!=1 || !is.numeric(n) || n<=0 || n!=as.integer(n)) stop("positive integer required")
  if (n %% 2 == 0) n/2 else 3*n+1
}

collatzSequence <- function(n) {
  if (length(n)!=1 || !is.numeric(n) || n<=0 || n!=as.integer(n)) stop("positive integer required")
  seq <- n
  while (n != 1) {
    n <- nextCollatz(n)
    seq <- c(seq, n)
  }
  list(sequence = seq, length = length(seq))
}

# Examples
nextCollatz(5)
nextCollatz(16)
collatzSequence(5)$sequence
collatzSequence(19)$sequence

```

## Shortest and longest Collatz sequences for starts 100–500 (ties → smallest start)

```{r}
results <- lapply(100:500, function(x) {
  s <- collatzSequence(x)
  data.frame(start=x, length=s$length)
})
df <- do.call(rbind, results)
df[which.min(df$length), ]
df[which.max(df$length), ]

```
